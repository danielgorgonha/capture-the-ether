const hre = require("hardhat");

async function main() {
  console.log("ğŸ” Iniciando exploit do GuessTheSecretNumberChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  // Se nÃ£o fornecido, fazemos o deploy primeiro
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("ğŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const GuessTheSecretNumberChallenge = await hre.ethers.getContractFactory("GuessTheSecretNumberChallenge");
    const guessChallenge = await GuessTheSecretNumberChallenge.deploy({
      value: hre.ethers.parseEther("1.0")
    });
    await guessChallenge.waitForDeployment();
    contractAddress = await guessChallenge.getAddress();
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const GuessTheSecretNumberChallenge = await hre.ethers.getContractFactory("GuessTheSecretNumberChallenge");
  const contract = GuessTheSecretNumberChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteBefore = await contract.isComplete();
  
  console.log("ğŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ğŸ‘¤ Atacante:", attacker.address);
  console.log("");
  console.log("ğŸ“Š Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // O hash que precisamos encontrar
  const answerHash = "0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365";
  
  console.log("ğŸ” Hash alvo:", answerHash);
  console.log("ğŸ’¡ Como o nÃºmero Ã© uint8 (0-255), podemos fazer brute force!\n");
  console.log("ğŸ” Procurando o nÃºmero secreto...\n");

  // Brute force: tentar todos os valores de 0 a 255
  let found = false;
  let secretNumber = null;

  for (let i = 0; i <= 255; i++) {
    // Calcular keccak256 do nÃºmero
    // Em Solidity 0.4.21, keccak256(uint8) faz hash do valor como um Ãºnico byte
    // Precisamos usar a mesma forma que o contrato usa
    // keccak256(uint8) em Solidity 0.4.21 faz hash do byte diretamente
    const byteValue = Buffer.from([i]);
    const hash = hre.ethers.keccak256(byteValue);
    
    if (hash.toLowerCase() === answerHash.toLowerCase()) {
      secretNumber = i;
      found = true;
      break;
    }
    
    // Mostrar progresso a cada 50 nÃºmeros
    if (i % 50 === 0 && i > 0) {
      process.stdout.write(`   Testando... ${i}/255\r`);
    }
  }

  if (!found) {
    console.log("\nâŒ NÃ£o foi possÃ­vel encontrar o nÃºmero secreto!");
    return;
  }

  console.log(`\nâœ… NÃºmero secreto encontrado: ${secretNumber}\n`);

  // Executar o exploit: adivinhar o nÃºmero secreto
  console.log(`ğŸ¯ Executando exploit: adivinhando o nÃºmero ${secretNumber}...\n`);
  
  const tx = await contract.guess(secretNumber, {
    value: hre.ethers.parseEther("1.0")
  });
  console.log("ğŸ“¤ Transaction enviada:", tx.hash);
  
  await tx.wait();
  console.log("âœ… Transaction confirmada!\n");

  // Verificar estado apÃ³s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("ğŸ“Š Estado apÃ³s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nğŸ‰ Desafio completado! O nÃºmero secreto foi encontrado e adivinhado corretamente");
    console.log("ğŸ’° VocÃª recebeu 2 ether de volta (1 ether enviado + 1 ether de lucro)");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

